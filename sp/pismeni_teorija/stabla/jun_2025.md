<img width="1015" height="213" alt="image" src="https://github.com/user-attachments/assets/1afb468d-38cf-41ff-a0e9-62a9cfa01ff8" />

<br><br>

# 1) Формирање бинарног стабла тражења (S)

Убацујемо елементе редом: **10, 15, 60, 12, 17, 5, 6, 7**. Правило: лево < родитељ < десно.

### Корак 1 — убаци 10

```
10
```

### Корак 2 — убаци 15 (15 > 10 → десно)

```
 10
   \
   15
```

### Корак 3 — убаци 60 (>10 → десно; >15 → десно)

```
  10
    \
    15
      \
      60
```

### Корак 4 — убаци 12 (>10 → десно; 12 < 15 → лево од 15)

```
   10
     \
     15
     / \
   12  60
```

### Корак 5 — убаци 17 (>10 → десно; >15 → десно; 17 < 60 → лево од 60)

```
     10
       \
       15
       / \
     12  60
         /
       17
```

### Корак 6 — убаци 5 (5 < 10 → лево)

```
      10
     /  \
    5   15
       /  \
     12   60
          /
        17
```

### Корак 7 — убаци 6 (6 < 10 → лево ка 5; 6 > 5 → десно од 5)

```
       10
      /  \
     5   15
      \  / \
      6 12  60
           /
         17
```

### Корак 8 — убаци 7 (7 <10 → лево; >5 → десно; >6 → десно од 6)

```
         10
        /  \
       5   15
        \  / \
        6 12  60
         \    /
          7  17
```

**Коначни BST (S)** (стрографички):

```
         10
        /  \
       5   15
        \  / \
        6 12 60
         \    /
          7  17
```

---

# 2) Формирање MinHeap-а (H) (по реду убацивања, „bubble-up“)

Почињемо празан heap (секвенцијална репрезентација, индексовање од 1).

Низ A редом: **10, 15, 60, 12, 17, 5, 6, 7**

Записујемо низ (после сваког уметања) и стабло.

### Корак 1 — додај 10

Array (1-based): `[10]`
Tree:

```
10
```

### Корак 2 — додај 15

Append → `[10, 15]` (15 ≥ 10 → остаје)
Tree:

```
  10
 /
15
```

### Корак 3 — додај 60

`[10, 15, 60]` (60 ≥ 10 → остаје)
Tree:

```
   10
  /  \
15   60
```

### Корак 4 — додај 12

Append → `[10,15,60,12]`. Родитељ на позицији 2 је 15, а 12 < 15 ⇒ размена (bubble-up) → `[10,12,60,15]`.
Tree:

```
     10
    /  \
   12  60
  /
 15
```

### Корак 5 — додај 17

Append → `[10,12,60,15,17]` (17 >= 12 → остаје)
Tree:

```
       10
      /  \
     12   60
    /  \
  15   17
```

### Корак 6 — додај 5

Append → `[10,12,60,15,17,5]`. Родитељ (index 3) = 60, 5 < 60 ⇒ swap → `[10,12,5,15,17,60]`. Сад родитељ index3 → index1 (10): 5 < 10 ⇒ swap → `[5,12,10,15,17,60]`.
Tree:

```
        5
      /   \
     12    10
    / \    /
  15 17  60
```

### Корак 7 — додај 6

Append → `[5,12,10,15,17,60,6]`. Родитељ index3 = 10, 6 < 10 ⇒ swap → `[5,12,6,15,17,60,10]`. Родитељ index3 → index1 (5): 6 >= 5 ⇒ стоп.
Tree:

```
         5
       /   \
      12    6
     / \   / \
   15 17 60 10
```

### Корак 8 — додај 7

Append → `[5,12,6,15,17,60,10,7]`. Родитељ index4 = 15; 7 < 15 ⇒ swap → `[5,12,6,7,17,60,10,15]`. Сада индекс новог чвора је 4, родитељ index2 = 12; 7 < 12 ⇒ swap → `[5,7,6,12,17,60,10,15]`. Родитељ index2 → index1 (5): 7 >= 5 ⇒ стоп.

**Коначни MinHeap (H) — секвенцијално (index 1..8):**
`[5, 7, 6, 12, 17, 60, 10, 15]`

Tree (последње стање):

```
           5
         /   \
        7     6
       / \   / \
     12 17 60 10
     /
   15
```

(однос индекса → позиције у стаблу: за node i, left = 2i, right = 2i+1)

---

# 3) Статичка (секвенцијална) репрезентација и опис елемената

## 3.1) BST (S) — статичка репрезентација (масив са NULL-има), индексовање од 1

Напомињемо: секвенцијална (array) репрезентација користи формулу left=2i, right=2i+1; јер наше стабло није „потпуно“, неке позиције су NULL.

Пошто у нашем стаблу постоје чворови на индексима до 14 (због положаја 17), низ (индекси 1..14):

| индекс   | 1  | 2 | 3  | 4    | 5 | 6  | 7  | 8    | 9    | 10   | 11 | 12   | 13   | 14 |
| -------- | -- | - | -- | ---- | - | -- | -- | ---- | ---- | ---- | -- | ---- | ---- | -- |
| вредност | 10 | 5 | 15 | NULL | 6 | 12 | 60 | NULL | NULL | NULL | 7  | NULL | NULL | 17 |

Овде:

* `S[1]=10` — корен.
* `S[2]=5` је лево дете корена; `S[3]=15` десно дете корена.
* `S[5]=6` — десно дете чвора на индексу 2 (5).
* `S[6]=12`, `S[7]=60` — деца чвора 15.
* `S[11]=7` — десно дете чвора 6 (индекс 5 → десно је 11).
* `S[14]=17` — лево дете чвора 60 (индекс 7 → лево 14).
* Остале позиције су `NULL` јер у нелинеарном (непотпуном) стаблу нема чвора на том месту.

**Опис елемената записаних у масиву:**

* свака позиција садржи или вредност чвора или NULL.
* везе су имплицитне: дете лево = позиција `2*i`, дете десно = `2*i+1`, родитељ = `⌊i/2⌋`.
* ова репрезентација је погодна за потпуне/квази-потпуне стабле; за разредна (sparse) стабла троши се меморија за NULL позиције.

## 3.2) BST (S) — динамичка (чвор + показивачи)

За сваки чвор (Node) опис:

```text
Node(value, left_pointer, right_pointer)
```

Листа чворова и њихове везе (поједностављено):

* Node(10): left -> Node(5), right -> Node(15)
* Node(5): left -> NULL, right -> Node(6)
* Node(6): left -> NULL, right -> Node(7)
* Node(7): left -> NULL, right -> NULL
* Node(15): left -> Node(12), right -> Node(60)
* Node(12): left -> NULL, right -> NULL
* Node(60): left -> Node(17), right -> NULL
* Node(17): left -> NULL, right -> NULL

**Опис поља:**

* `value` — садржај чвора (нпр. 10, 5, ...).
* `left`, `right` — показивачи (адресе) на одговарајуће дечије чворове или `NULL` ако нема детета.
* додатно може бити показивач на родитеља (опционо), или метаподаци (висина, баланс фактор итд.).

---

## 3.3) MinHeap (H) — статичка (секвенцијална) репрезентација

Коначни низ (index 1..8):
`H = [5, 7, 6, 12, 17, 60, 10, 15]`

Тумачење:

* `H[1]=5` — корен (минимум).
* `H[2]=7`, `H[3]=6` — деца корена.
* `H[4]=12`, `H[5]=17` — деца `H[2]`.
* `H[6]=60`, `H[7]=10` — деца `H[3]`.
* `H[8]=15` — лево дете `H[4]` (jer 2*4=8).

**Опис елемената:**

* код heap-а секвенцијална репрезентација је природна и ефикасна: за node на i, left=2i, right=2i+1, parent=⌊i/2⌋.
* heap property: за сваки i, H[i] ≤ H[2i] и H[i] ≤ H[2i+1] (ако постоје).

## 3.4) MinHeap (H) — динамичка репрезентација (чворови + показивачи)

Чворови:

* Node(5): left->Node(7), right->Node(6)
* Node(7): left->Node(12), right->Node(17)
* Node(6): left->Node(60), right->Node(10)
* Node(12): left->Node(15), right->NULL
* Node(17): left->NULL, right->NULL
* Node(60): left->NULL, right->NULL
* Node(10): left->NULL, right->NULL
* Node(15): left->NULL, right->NULL

Опис поља је исто: `value`, `left`, `right`. Код динамичке репрезентације везе су експлицитне (показивачи).

---

# 4) Брисање чвора са вредношћу **6** из MinHeap-а (H) — поступак корак по корак

Имамо тренутни `H` (секвенцијално):
`[5, 7, 6, 12, 17, 60, 10, 15]` (индекс 1..8)

Желимо да избришемо чвор чија је **вредност = 6**.

У MinHeap-у брисање произвољног елемента (не само корена) обично радимо овако:

1. Пронађемо индекс елемента који желимо да избришемо.
   → **6** се налази на индексу `i = 3`.

2. Заменимо тај елемент са последњим елементом у низу (последњи = на index `n`), и смањимо величину низа за 1 (уклонимо последњи).

   * Последњи елемент је `H[8] = 15`.
   * Урадимо: `H[3] ← H[8]` и обришемо H[8].

   После размештања (пре хеапификације):

   ```
   Индекси: 1  2  3  4   5   6   7
   H:       5, 7, 15,12, 17, 60,10
   ```

   (величина је сада `n=7`)

   Графички (пре прилагођавања):

   ```
           5
         /   \
        7     15   ← (сад на месту где је била 6)
       / \   / \
     12 17 60 10
   ```

3. Сада треба вратити heap својство. За индекс `i=3` имамо нову вредност 15. Проверимо да ли треба „bubble-up“ (према горе) или „bubble-down“ (heapify down).

   * Родитељ `i=3` је `i_parent = ⌊3/2⌋ =1`, `H[1] = 5`. Пошто `15 ≥ 5`, нема подизања.
   * Проверавамо децу: left `2*i=6` → 60, right `2*i+1=7` → 10. Минимално дете међу њима је `10` (index 7). Пошто `15 > 10`, треба swap са малоњим дететом (heapify down).

4. Swap `H[3]` и `H[7]` (15 ↔ 10):
   Након swap:
   `H = [5, 7, 10, 12, 17, 60, 15]` (н = 7)

   Tree:

   ```
         5
       /   \
      7     10
     / \   / \
   12 17 60 15
   ```

5. Нови положај старе вредности (15) је индекс 7. Проверимо његова деца: `2*7 = 14 > n` — нема деце. Значи heapify down је завршен. Нема потребе за bubble-up (jer 10 >= parent 5).

**Коначан heap након брисања 6:**
`[5, 7, 10, 12, 17, 60, 15]`

Графички:

```
        5
      /   \
     7     10
    / \   / \
  12 17 60 15
```

---

# 5) Кратке напомене / објашњења

* **BST уметање**: сваки нови елемент путује од корена: ако мањи → лево, ако већи → десно. У нашем случају добили смо „небалансирано“ стабло (лево и десно су различитих дубина).
* **MinHeap изградња**: корисна је секвенцијална репрезентација (`array`) и операције `insert` (append + bubble-up) и `delete-min` (корен заменити последњим + bubble-down). Брисање произвољног елемента (као 6) ради се замјеном са последњим елементом и затим bubble-up или bubble-down по потреби — ми смо извршили bubble-down.
* **Статичка репрезентација** (array) је ефикасна за heap (није претерано „рашчлањена“), али за произвољни BST који није комплетан троши више простора због NULL позиција.
* **Динамичка репрезентација** (чворови + показивачи) је меморијски економичнија за разређена стабла и олакшава операције као што су додатна поља (родитељ, висина, баланс) и лаке реорганизације.

