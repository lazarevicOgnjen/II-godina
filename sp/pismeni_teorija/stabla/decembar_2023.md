<img width="1718" height="357" alt="image" src="https://github.com/user-attachments/assets/7820f230-9536-41e8-b93a-8316c0628ab2" />

<br><br>

# 1) Формирање бинарног трагачког стабла S — корак по корак (са графичким приказом)

Убацујемо елементе у датом редоследу у BST (стандардно: лево < родитељ, десно > родитељ).

**Почетак: празно стабло**

1. Убаци 13 (постаје корен)

```
13
```

2. Убаци 2 (2 < 13 → лево)

```
  13
 /
2
```

3. Убаци 1 (1 < 13 → лево; 1 < 2 → лево)

```
   13
  /
 2
/
1
```

4. Убаци 18 (18 > 13 → десно)

```
   13
  /  \
 2    18
/
1
```

5. Убаци 7 (7 < 13 → лево; 7 > 2 → десно)

```
    13
   /  \
  2    18
 / \
1   7
```

6. Убаци 25 (25 > 13 → десно; 25 > 18 → десно)

```
     13
    /  \
   2    18
  / \     \
 1   7     25
```

7. Убаци 8 (8 < 13 → лево; 8 > 2 → десно; 8 > 7 → десно)

```
      13
     /  \
    2    18
   / \     \
  1   7     25
       \
        8
```

То је коначни облик BST S. (Јасније у виду нивоа:)

```
        13
       /  \
      2    18
     / \     \
    1   7     25
         \
          8
```

---

# 2) Формирање Max-Heap H од низа A — корак по корак (са графичким приказом)

Правимо бинарни максимални хип (потпуно бинарно стабло, сређено по својству heap) убацујући редом елементе и "sift-up" (померање горе) по потреби. Представићу хип и као низ (пошто је обичан начин представљања хипа) и као стабло.

Почетно празно.

1. Убаци 13 → heap = [13]

```
13
```

2. Убаци 2 → heap = [13, 2] (2 ≤ 13, нема промена)

```
  13
 /
2
```

3. Убаци 1 → heap = [13, 2, 1] (1 ≤ 13)

```
   13
  /  \
 2    1
```

4. Убаци 18 → append → [13,2,1,18]; sift-up: 18 > 2 → swap → [13,18,1,2]; 18 > 13 → swap → **[18,13,1,2]**

```
      18
     /  \
   13    1
  /
 2
```

5. Убаци 7 → append → [18,13,1,2,7]; 7 ≤ 13 → нема промена

```
       18
      /  \
    13    1
   /  \
  2    7
```

6. Убаци 25 → append → [18,13,1,2,7,25]; sift-up: 25 > 1 → swap → [18,13,25,2,7,1]; 25 > 18 → swap → **[25,13,18,2,7,1]**

```
        25
       /  \
     13    18
    / \   /
   2  7  1
```

7. Убаци 8 → append → [25,13,18,2,7,1,8]; 8 ≤ 18 → нема промена
   Коначни heap као низ: **[25, 13, 18, 2, 7, 1, 8]**

Графички:

```
        25
       /  \
     13    18
    / \   / \
   2  7  1  8
```

(Сваког корака сам показао стање после сређивања – то је „графички изглед стабла H након сваког корака“.)

---

# 3) Опис поступка брисања чвора из бинарног трагачког стабла S

Стандардне три ситуације при брисању чвора `x` у BST:

1. **Чвор x је лист (нема деце)**
   -> једноставно га уклонити (поставити показивач родитеља лево/десно на `null`).

2. **Чвор x има једног потомка (само лево или само десно дете)**
   -> заменити чвор x његовим јединим потомком (подесити показивач родитеља да показује на пото-ка), затим ослободити x.

3. **Чвор x има два потомка (лево и десно)**
   Стандардан приступ:

   * Наћи **ин-орд следбеника** (in-order successor) — минимални (најлевљи) чвор у десном подстаблу x, или опционално ин-орд претходника (макс у левом подстаблу).
   * Копирати вредност следбеника у позицију x (замена вредности).
   * Избрисати (рекурзивно) самог следбеника (који ће имати највише једно дете — јер је минимум у неком подстаблу).
     Ово очувава BST својство.

Детаљи: приликом брисања воде се показивачи родитеља и деце, пази се на случаје кад се брише корен (тада се корен мења).

---

# 4) Практичан сценарио: брисање чвора са вредношћу **2** из нашег BST S — корак по корак

Подсетимо коначно S пре брисања:

```
        13
       /  \
      2    18
     / \     \
    1   7     25
         \
          8
```

Тражимо чвор са вредношћу `2`. Видећете да `2` има **двоје потомака** (лево = `1`, десно = `7`). Працимо по процедури за случај са два потомка — користићемо **ин-орд следбеника** (минимум у десном подстаблу).

**Корак 1 — пронађи чвор који бришемо**

* Чвор N = 2; има лево дете 1 и десно дете 7.

**Корак 2 — нађи ин-орд следбеника Suc**

* Десно подстабло од N је стабло чији корен је 7.
* Минимални (најлевљи) чвор у том подстаблу је сам `7` (јер 7 нема лево дете).
  Dakle `Suc` = 7.

**Корак 3 — замени вредност чвора N вредношћу следбеника**

* Уместо `2` уместо стављамо `7`.
* Сад структура (вредности) привидно:

```
        13
       /  \
      7    18
     / \     \
    1   7     25
         \
          8
```

(Напомена: имамо дупликатну вредност 7 — један на месту где је био 2, други где је био следбеник.)

**Корак 4 — избриши оригинални следбеник (стари чвор са вредношћу 7 у десном подстаблу N)**

* Оригинални чвор `7` (у десном подстаблу) има само једно дете — десно дете `8`. (Нема лево дете.)
* По правилу за чвор са једним потомком: заменимо тај чвор његовим дететом (тј. родитељ показује на `8` уместо на `7`).

Резултат после уклањања старог 7 и повезивања 8:

```
        13
       /  \
      7    18
     / \     \
    1   8     25
```

То је коначно стабло S након брисања чвора са вредношћу 2 (пре него што смо заменили га — али крајњи резултат: број `2` више нема, на његовом месту стоји 7, а стари чвор 7 је замењен својим дететом 8).

(Ако бисмо хтели да прикажемо само вредности — коначни S изгледа као горе.)

---

# Кратка рекапitulција (са корисним напоменама)

* BST S направљено редом A је:

```
        13
       /  \
      2    18
     / \     \
    1   7     25
         \
          8
```

* Max-Heap H направљен редом A (после сваког убацивања сам извршио sift-up) коначно је:

```
        25
       /  \
     13    18
    / \   / \
   2  7  1  8
```

* Процедура брисања у BST има 3 случаја (лист, једно дете, два детета). За два детета користимо copy+delete ин-орд следбеника/претходника.
* Бришући `2` у нашем BST добијамо крајње стабло:

```
        13
       /  \
      7    18
     / \     \
    1   8     25
```


